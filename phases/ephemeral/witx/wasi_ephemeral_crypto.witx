;; WASI Cryptography API.
;;
;; This is a `witx` file. See [here](https://github.com/WebAssembly/WASI/tree/master/docs/witx.md)
;; for an explanation of what that means.

(use "typenames.witx")

(module $wasi_ephemeral_crypto
  ;;; Linear memory to be accessed by WASI functions that need it.
  (import "memory" (memory))

  ;;; Open a handle for cipher operations.
  (@interface func (export "cipher_open")
    ;;; The key for this operation.
    (param $private_key $private_key)
    (result $error $errno)
    ;;; The cipher handle that has been opened.
    (result $new_state $cipher_state_initial)
  )

  ;;; Set the nonce or initialization vector (IV).
  ;;;
  ;;; This affects both encryption and decryption.
  (@interface func (export "cipher_set_nonce")
    (param $state $cipher_state_initial)
    ;;; The nonce to set for this message.
    (param $nonce (@witx const_pointer u8))
    (param $nonce_len $size)
    (result $error $errno)
  )

  ;;; Set the additional authentication data (AAD). This works only if
  ;;; the cipher algorithm is AEAD (Authenticated Encryption with
  ;;; Additional Data); otherwise `errno::inval`is returned.
  (@interface func (export "cipher_set_auth_data")
    (param $state $cipher_state_initial)
    ;;; The additional data to be authenticated.
    (param $auth (@witx const_pointer u8))
    (param $auth_len $size)
    (result $error $errno)
  )

  ;;; Get the authentication tag generated by the last encryption
  ;;; operation.  This only works if the cipher algorithm is AEAD
  ;;; (Authenticated Encryption with Additional Data); otherwise
  ;;; `errno::inval`is returned.
  (@interface func (export "cipher_get_auth_tag")
    (param $state $cipher_state_initial)
    ;;; The buffer where the authentication tag is stored. The length
    ;;; must be equal to or shorter than the tag length specified for
    ;;; the algorithm.  If it is shorter, only the first `tag_len`
    ;;; bytes are written to `tag`.
    (param $tag (@witx pointer u8))
    (param $tag_len $size)
    (result $error $errno)
  )

  ;;; Set the authentication tag for plaintext authentication. This
  ;;; only works if the cipher algorithm is AEAD (Authenticated
  ;;; Encryption with Additional Data); otherwise `errno::inval` is
  ;;; returned.
  (@interface func (export "cipher_set_auth_tag")
    (param $state $cipher_state_initial)
    ;;; The authentication tag.
    (param $tag (@witx const_pointer u8))
    (param $tag_len $size)
    (result $error $errno)
  )

  ;;; Initiate a series of encryption operations.
  (@interface func (export "cipher_encrypt_begin")
    (param $state $cipher_state_initial)
    (result $error $errno)
    (result $new_state $cipher_state_encrypting)
  )

  ;;; Encrypt a single message.
  (@interface func (export "cipher_encrypt")
    (param $state $cipher_state_encrypting)
    ;;; The plaintext to be encrypted.
    (param $plaintext (@witx const_pointer u8))
    (param $plaintext_len $size)
    ;;; The buffer where the resulting ciphertext is stored. This can
    ;;; overlap with `plaintext`.
    (param $ciphertext (@witx pointer u8))
    (param $ciphertext_len $size)
    (result $error $errno)
  )

  ;;; Finalize a series of encryption operations.
  (@interface func (export "cipher_encrypt_end")
    (param $state $cipher_state_encrypting)
    (result $error $errno)
    (result $new_state $cipher_state_initial)
  )

  ;;; Initiate a series of decryption operations.
  (@interface func (export "cipher_decrypt_begin")
    (param $state $cipher_state_initial)
    (result $error $errno)
    (result $new_state $cipher_state_decrypting)
  )

  ;;; Decryption a single message.
  (@interface func (export "cipher_decrypt")
    (param $state $cipher_state_decrypting)
    ;;; The ciphertext to be decrypted.
    (param $ciphertext (@witx const_pointer u8))
    (param $ciphertext_len $size)
    ;;; The buffer where the resulting plaintext is stored. This can
    ;;; overlap with `plaintext`.
    (param $plaintext (@witx pointer u8))
    (param $plaintext_len $size)
    (result $error $errno)
  )

  ;;; Finalize a series of decryption operations.
  (@interface func (export "cipher_decrypt_end")
    (param $state $cipher_state_decrypted)
    (result $error $errno)
    (result $new_state $cipher_state_initial)
  )

  ;;; Close a handle for cipher operations. The closed handle cannot
  ;;; be used afterwards.
  (@interface func (export "cipher_close")
    (param $state $cipher_state_initial)
    (result $error $errno)
  )

  ;;; Create a handle for secure hashing operations.
  (@interface func (export "hash_open")
    ;;; The name of the hash algorithm, either predefined or defined
    ;;; by the implementation. The currently defined value are
    ;;; `SHA-1`, `SHA-224`, `SHA-256`, `SHA-384`, `SHA-512`,
    ;;; `SHA3-224`, `SHA3-256`, `SHA3-384`, and `SHA3-512`.
    (param $algorithm string)
    (result $error $errno)
    (result $new_state $hash_state_initial)
  )

  ;;; Feed some data for hashing. This function can be called as many
  ;;; times while the hash handle remains open.
  (@interface func (export "hash_update")
    (param $state $hash_state_initial)
    ;;; The data to be hashed.
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $errno)
  )

  ;;; Extract the hash value. This function can be called as many
  ;;; times while the hash handle remains open and it is safe to call
  ;;; `hash_update` subsequently.
  (@interface func (export "hash_digest")
    (param $state $hash_state_initial)
    ;;; The buffer where the digest value is stored. For XOF
    ;;; (Extensible Output Function) such as SHAKE, the length can be
    ;;; arbitrary as long as it is smaller than the size allocated for
    ;;; `digest`. Otherwise, the length must be equal to or shorter
    ;;; than the tag length specified for the algorithm.  If it is
    ;;; shorter, only the first `digest_len` bytes are written to
    ;;; `digest`.
    (param $digest (@witx pointer u8))
    (param $digest_len $size)
    (result $error $errno)
  )

  ;;; Close a handle for secure hashing operations. The closed handle
  ;;; cannot be used afterwards.
  (@interface func (export "hash_close")
    (param $state $hash_state_initial)
    (result $error $errno)
  )

  ;;; Create a handle of signing operation. The operation can be
  ;;; either a public key signing or a MAC (Message Authentication
  ;;; Code) algorithm.
  (@interface func (export "sign_open")
    ;;; The name of the signing algorithm. This is either from the
    ;;; IANA assignments of JOSE (JSON Object Signing and Encryption)
    ;;; or defined by the host implementation.
    (param $algorithm string)
    ;;; The key for this operation.
    (param $private_key $private_key)
    (result $error $errno)
    (result $new_state $sign_state_initial)
  )

  ;;; Set the nonce for the subsequent signing operation. This
  ;;; function must be called before `sign_update` or `sign_digest` is
  ;;; called.
  (@interface func (export "sign_set_nonce")
    (param $state $sign_state_initial)
    ;;; The nonce for this operation.
    (param $nonce (@witx const_pointer u8))
    (param $nonce_len $size)
    (result $error $errno)
  )

  ;;; Initiate a series of signing operations.
  (@interface func (export "sign_begin")
    (param $state $sign_state_initial)
    (result $error $errno)
    (result $new_state $sign_state_signing)
  )

  ;;; Feed some data to be signed. This function can be called as many
  ;;; times while the sign handle is open.
  (@interface func (export "sign_update")
    (param $state $sign_state_signing)
    ;;; The data to be signed.
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $errno)
  )

  ;;; Extract the signature. This function can be called as many times
  ;;; while the sign handle is open and it is safe to call
  ;;; `sign_update` subsequently. That is particularly useful when the
  ;;; algorithm is MAC (Message Authentication Code).
  (@interface func (export "sign")
    (param $state $sign_state_signing)
    ;;; The buffer where the generated signature is stored. The length
    ;;; must be equal to or shorter than the output length specified
    ;;; for the algorithm.  If it is shorter, only the first
    ;;; `signature_len` bytes are written to `signature`.
    (param $digest (@witx pointer u8))
    (param $digest_len $size)
    (result $error $errno)
  )

  ;;; Complete a series of signing operations.
  (@interface func (export "sign_end")
    (param $state $sign_state_signing)
    (result $error $errno)
    (result $new_state $sign_state_initial)
  )

  ;;; Close a handle for signing operations.
  (@interface func (export "sign_close")
    (param $state $sign_state_initial)
    (result $error $errno)
  )

  ;;; Prepare a handle for private key generation for an
  ;;; algorithm. The algorithm can be a public key encryption and
  ;;; signing algorithms, a symmetric key encryption, MAC, or key
  ;;; derivation.
  (@interface func (export "generate_key_prepare")
    ;;; The name of the algorithm which the resultant private key is
    ;;; used with. This is either from the IANA assignments of JSON
    ;;; Object Signing and Encryption (JOSE) or defined by the host
    ;;; implementation.
    (param $algorithm string)
    (result $error $errno)
    (result $new_state $generate_key_state_initial)
  )

  ;;; Set the nonce needed for some algorithms. For example, to
  ;;; generate a pseudo-random key with HKDF-Extract, it is an
  ;;; optional salt value.
  (@interface func (export "generate_key_set_nonce")
    (param $state $generate_key_state_initial)
    (param $nonce (@witx const_pointer u8))
    (param $nonce_len $size)
    (result $error $errno)
  )

  ;;; Set the input keying material shall be used as a base of the
  ;;; generated private key for some algorithms.
  (@interface func (export "generate_key_set_input")
    (param $state $generate_key_state_initial)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $errno)
  )

  ;;; Set the hash algorithm used for the private key generation.
  (@interface func (export "generate_key_set_hash")
    (param $state $generate_key_state_initial)
    (param $hash_state $hash_state_initial)
    (result $error $errno)
  )

  ;;; Generate a private key and close the handle for the private key
  ;;; generation operation. The closed handle cannot be used
  ;;; afterwards.
  (@interface func (export "generate_key")
    (param $state $generate_key_state_initial)
    (result $error $errno)
    (result $private_key $private_key)
  )

  ;;; Prepare a handle for key derivation for an algorithm. The
  ;;; algorithm can be either a KDF (Key Derivation Function)
  ;;; algorithm or a shared secret derivation algorithm.
  (@interface func (export "derive_key_prepare")
    (param $algorithm string)
    (param $private_key $private_key)
    (result $error $errno)
    (result $new_state $derive_key_state_initial)
  )

  ;;; Set the nonce for the key derivation operation for some
  ;;; algorithms. For example, to derive an output keying material
  ;;; with HKDF-Expand, it is an additional "info" value.
  (@interface func (export "derive_key_set_nonce")
    (param $state $derive_key_state_initial)
    ;;; The nonce value (a non-secret random value).
    (param $nonce (@witx const_pointer u8))
    (param $nonce_len $size)
    (result $error $errno)
  )

  ;;; Set hash algorithm for the key derivation operation.
  (@interface func (export "derive_key_set_hash")
    (param $state $derive_key_state_initial)
    (param $hash_state $hash_state_initial)
    (result $error $errno)
  )

  ;;; Derive a secret and close the handle for the key derivation
  ;;; operation. The closed handle cannot be used afterwards.
  (@interface func (export "derive_key")
    (param $state $derive_key_state_initial)
    ;;; The buffer where the generated key or secret is stored. The
    ;;; length must be equal to or shorter than the tag length
    ;;; specified for the algorithm.  If it is shorter, only the first
    ;;; `output_len` bytes are written to `output`.
    (param $output (@witx pointer u8))
    (param $output_len $size)
    (result $error $errno)
  )
)
